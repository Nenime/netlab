Вся это - не более чем попытка описать непонятно откуда взявшуюся у меня в голове информацию, полнота и достоверность которой никак не гарантируются.

### Содержание
**[Установка демонстрационного стенда](#Установка-демонстрационного-стенда)**  
**[Канальный уровень (L2)](#Канальный-уровень-(l2))**  
**[L2 - Пробуем посмотреть](#l2---пробуем-посмотреть)**  

## Установка демонстрационного стенда
Качаем образ ubuntu-netlab.ova: https://yadi.sk/d/RLELDKKWgM5mi и импортируем его в VirtualBox (>5.0). Логин - ubuntu, пароль - ubuntu. Рекомендуется настроить доступ по ssh (выбираем Сеть - NAT и настраиваем проброс портов, порт хост-системы 10022, порт гостя - 22, адреса можно не заполнять).

## Канальный уровень (L2)
### L2 - базовое
Далее все будем рассматривать на примере Ethernet - технологии с разделяемой средой передачи, т.е. несколько устройств можно физически подключить к одному кабелю (к коаксиалу через тройники, например). Вот этот кабель с тройниками будет называться Collision Domain. Потому что когда 2 и более узла начинают слать сигналы одновременно, происходит коллизия, и извлечь из получившегося что-то интересное - тяжело. А чтобы уменьшить количество коллизий - применяется CSMA/CD. Уровень модели OSI - физический (L1). Он нам обычно не интересен.

Следующий этап - сетевая карта, которая умеет из сигналов в кабеле делать биты и байты. А еще упаковывать эти байты в кадры (frames) перед тем, как отдать операционной системе (и распаковывать обратно в сигналы). Уровень - канальный (link-layer, L2). На этом уровне появляется необходимость определять начало-конец кадра, от какого узла и к какому он шел (возможно, вообще не к нам, среда передачи же общая).

Вводится адресация - MAC address, уникальный для каждой карты (6 байт, первые 3 - код производителя). https://www.wireshark.org/tools/oui-lookup.html - тут можно вычислить производителя по маку и посмотреть примеры написания адресов (cisco очень любит их через "-"). Destination адреса у кадров бывают специальные ("всем" и "почти всем"). "Всем" - это broadcast, ff:ff:ff:ff:ff:ff. "Почти всем" - это multicast, с ним сложно и потом. Когда сетевушка получает кадр с dst-mac отличный от своего и "всем", она его отбрасывает. Если не переключить ее в promiscuous mode, конечно (через `ip link set dev eth0 promisc on`, например, `tcpdump` автоматически умеет переключать) - тогда начнет все принимать. Никаких ограничений на уникальность адресов не накладывается. Получили кадр с правильным dst - приняли.

Заходим на https://en.wikipedia.org/wiki/Ethernet_frame и бегло смотрим, там 3 интересные вещи. Первая - dst mac идет первым, потому что часто это все, что нужно знать оборудованию про кадр, а памяти для его хранения целиком может не быть. Вторая - на схеме кадра, optional у 802.1Q (что бы это ни было) тега значит, что его там вообще может не быть. Совсем. Прям длина кадра будет разной при одинаковой payload, и сетевому оборудованию надо явно говорить, что вот на этих портах есть тег, а на этих - нету, и действие (убрать/добавить тег) в зависимости от этого. Само оно никак не определит. Третья - ether type (https://en.wikipedia.org/wiki/EtherType#Examples) у кадра нужен в частности для того, чтобы ОС поняла, какой код-обработчик payload ей дергать в ядре, ipv6, ipv4, arp и тд. Передать payload в нужный сетевой стек - этот процесс еще так называют.

Про оборудование - кабели можно не только тройниками соединять, но и воткнуть в hub. Это физический соединитель, тот же тройник, но на много портов, про байты и кадры ничего не знает. Еще к нему можно питание подвести и сигнал усиливать, чтобы узлы дальше друг от друга ставить. Хосты в хабе - это тоже collision domain. Bridge (мост) - уже знает про байты, соединяет 2 разных collision domain (кабеля), но не просто так, а перкладывая кадр из одного в другой. Например, если с двух сторон моста разные физические технологии. Switch (коммутатор) - несколько collision domain (и портов), свитч и мост - практически одно и то же. Куча свитчей, мостов и хабов - это Broadcast Domain, в нем всюду может добраться mac с broadcast dst (ff:...).

Свитч умный, и может перекладывать кадр только туда, где скорее всего есть получатель. Вот тут самое интересное. Сначала, он не знает ничего о сети, поэтому пересылает полученный кадр во все остальные порты. Но это не всегда broadcast, а часто unicast flood, т.к. dst-mac у кадра не меняется и может предназначаться только одному узлу. У свитча обычно есть аппаратный хеш (content adressable memory, или, mac table) вида {mac}->(port, age). Свитч пишет в хеш, какой src-mac с какого порта пришел (исключая broadcast). Чтобы записи не жили вечно, при получении кадра обновляет еще и счетчик времени age, по истечении которого удаляет запись. В итоге, если попадается кадр, dst mac которого совпадает с табличным, и табличный порт не тот же самый, откуда кадр пришел - перекладываем в табличный. Мак-таблица может переполниться, тогда скорее всего придется устраивать unicast flood, пока какая-нибудь запись в ней не протухнет.
### L2 - пробуем посмотреть
#### Создаем новый bridge и цепляем к нему 2 контейнера
```bash
lxc network create l2br0 ipv4.nat=false ipv6.nat=false ipv4.address=none ipv6.address=none
for i in x{1..2}; do
    /usr/local/bin/create-vm.sh l2br0
done
```

Должно получится 2 виртуалки (x1, x2):
```bash
root@ubuntu-netlab:~# lxc list
+------+---------+------+------+------------+-----------+
| NAME |  STATE  | IPV4 | IPV6 |    TYPE    | SNAPSHOTS |
+------+---------+------+------+------------+-----------+
| x0   | STOPPED |      |      | PERSISTENT | 0         |
+------+---------+------+------+------------+-----------+
| x1   | RUNNING |      |      | PERSISTENT | 0         |
+------+---------+------+------+------------+-----------+
| x2   | RUNNING |      |      | PERSISTENT | 0         |
+------+---------+------+------+------------+-----------+
root@ubuntu-netlab:~# lxc exec x1 bash
root@x1:~# ifconfig
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:4 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1
          RX bytes:248 (248.0 B)  TX bytes:248 (248.0 B)

root@x1:~# cat /etc/network/interfaces.d/50-cloud-init.cfg
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet manual

# для x2 должно быть аналогично
```
#### brctl, тестовый трафик
`l2br0` - это linux-bridge (фактически, свитч), его можно было создать и руками через `brctl`. Можно посмотреть, какие локальные интерфейсы ("порты свитча") включены в созданный бридж, какие бриджи есть в системе. И вообще поиграться с brctl.

Таблица мак-адресов:
```bash
root@ubuntu-netlab:~# brctl showmacs l2br0 | grep no # хотим смотреть только не-локальные адреса
port no	mac addr		is local?	ageing timer
```
Ее там в идеале не должно быть, потому что все интерфейсы в виртуалках выключены (но из-за бага они стартуют включенными, поэтому какие-то записи могут быть).

1. Запустите tcpdump на хост-системе - `root@ubuntu-netlab:~# tcpdump -Al -evv -i l2br0`. Войдите в первый контейнер `lxc exec x1 bash` и поднимите интерфейс `ifup eth0`. Сгенерируйте с контейнера трафик:
 * `root@x1:~# ping -I eth0 -b 255.255.255.255`
 * `root@x1:~# ping6 -I eth0 ip6-allhosts`
 * `root@x1:~# arping -I eth0 -B -0`
 
 Посмотрите на расшифровку полей в ethernet-кадре (в tcpdump). Проверьте `brctl showmacs`.

2. Войдите во второй контейнер, убедитесь, что интерфейс eth0 выключен (`ip link sh | grep DOWN` или `ethtool eth0`), если нет - потушите . Скопируйте mac интерфейса eth0:
 ```bash
root@ubuntu-netlab:~# lxc exec x2 bash
root@x2:~# ifconfig -a | grep eth0 # или ip link show
```

 Запустите в первом контейнере `root@x1:~# tcpdump -Al -evv -i eth0` и отправьте arp-запросы на mac второго контейнера: `root@ubuntu-netlab:~# arping -I l2br0 -0 00:16:3e:c3:4e:e3`. Убедитесь, что запросы попадают в первый контейнер, хотя это не его мак.

 Войдите во второй контейнер и поднимите интерфейс `root@x2:~# ifup eth0`. Через некоторое время запросы в первый контейнер прекратятся.

3. Установите в первом контейнере mac от второго: `root@x1:~# ip link set dev eth0 address 00:16:3e:c3:4e:e3`. Поочередно генерируйте трафик с контейнеров - порт и ageing timer в `brctl showmacs` будут меняться.

### L2 - VLAN
## L3
